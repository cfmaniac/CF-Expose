<!--- getDumpScope ---><cfComponent	Hint	= ""	Output	= "no"	Extends	= "CFExpose.ComponentExtension">	<cfFunction		name		= "jsonToDumpObject"		returnType	= "any"		access		= "public"		output		= "no"		description	= ""		hint		= ""	>		<cfArgument name="CFUnitConsoleJSON" required="no" type="string" hint="" />		<cfScript>			var local = structNew();			if(structKeyExists(arguments, "CFUnitConsoleJSON") AND isJSON(arguments.CFUnitConsoleJSON))			{				structAppend(arguments, deserializeJson(arguments.CFUnitConsoleJSON));				structDelete(form, "CFUnitConsoleJSON");				structDelete(url, "CFUnitConsoleJSON");				if(structKeyExists(form, "fieldnames"))				{					local.listNum = listFindNoCase(form.fieldnames,'CFUnitConsoleJSON');					if(local.listNum)						form.fieldnames = listDeleteAt(form.fieldnames, local.listNum);				}			}			return dumpObject(argumentCollection=arguments);		</cfScript>	</cfFunction>	<cfFunction		name		= "invokationToResultArray"		returnType	= "array"		access		= "public"		output		= "no"		description	= ""		hint		= ""	>		<cfArgument name="functionCode"					required="no"	type="string"							hint="" />		<cfArgument name="SubFunctionEvaluateCode"		required="no"	type="string"							hint="" />		<cfScript>			var local = structNew();			local.returnArray = arrayNew(1);			if(structKeyExists(arguments, "functionCode") AND len(arguments.functionCode))				local.functionCode = functionEvaluateNotation(arguments.functionCode);			if(structKeyExists(local , "functionCode"))			{				arguments.dumpObject = local.functionCode;				arrayAppend(local.returnArray, arguments.dumpObject);				if(structKeyExists(arguments, "SubFunctionEvaluateCode") AND len(arguments.SubFunctionEvaluateCode))				{					local.functionCode = isolateEvaluateString(arguments.SubFunctionEvaluateCode,arguments.dumpObject);					if(structKeyExists(local , "functionCode"))					{						arguments.dumpObject = local.functionCode;						arrayAppend(local.returnArray, arguments.dumpObject);					}				}			}else if(structKeyExists(arguments, "SubFunctionEvaluateCode") AND len(arguments.SubFunctionEvaluateCode))			{				local.functionCode = isolateEvaluateString(arguments.SubFunctionEvaluateCode);				if(structKeyExists(local , "functionCode"))					arrayAppend(local.returnArray, local.functionCode);			}			return local.returnArray;		</cfScript>	</cfFunction>	<cfFunction		name		= "isolateEvaluateString"		returnType	= "any"		access		= "public"		output		= "no"		description	= ""		hint		= ""	>		<cfArgument name="evaluateString"	required="yes"	type="string"	hint="" />		<cfArgument name="parentObject"		required="no"	type="any"		hint="" />		<cfScript>			arguments.variablesScope = getIncludeVariableStruct();			if(structKeyExists(arguments, "parentObject"))			{				request.temp = arguments.parentObject;				arguments.evaluateString = 'request.temp.' & arguments.evaluateString;			}			local.return = functionEvaluateNotation('<cfReturn #arguments.evaluateString# />');			return local.return;		</cfScript>	</cfFunction>	<cfFunction		name		= "setIncludeVariableStruct"		returnType	= "any"		access		= "public"		output		= "no"		description	= ""		hint		= ""	>		<cfArgument name="IncludeVariableStruct" required="yes" type="struct" hint="" />		<cfset variables.IncludeVariableStruct = arguments.IncludeVariableStruct />		<cfReturn this />	</cfFunction>	<cfFunction		name		= "getIncludeVariableStruct"		returnType	= "struct"		access		= "public"		output		= "no"		description	= ""		hint		= ""	>		<cfif NOT structKeyExists(variables, "IncludeVariableStruct")>			<cfReturn structNew() />		</cfif>		<cfReturn variables.IncludeVariableStruct />	</cfFunction>	<cfFunction		Name			= "dumpObject"		returnType		= "string"		Access			= "public"		Output			= "no"		description		= "main method used once remote session established"		Hint			= ""	>		<cfArgument name="functionCode"					required="no"	type="string"			hint="" />		<cfArgument name="SubFunctionEvaluateCode"		required="no"	type="string"			hint="" />		<cfArgument name="expand"						required="no"	type="boolean"		default="yes" hint="" />		<cfArgument name="asMetaData"					required="no"	type="boolean"		default="no" hint="" />		<cfArgument name="returnStringFormatMode"		required="no"	type="variableName"	default="textarea" hint="" />		<cfArgument name="isReturnUnformattedQuerySql"	required="no"	type="boolean"		default="yes" hint="" />		<cfArgument name="dumpFormat"					required="no"	type="variableName"	default="html" hint="" />		<cfArgument name="dumpTop"						required="no"	type="string"			hint="" />		<cfArgument name="showUDFs"						required="no"	type="boolean"		default="no" hint="" />		<cfArgument name="requestTimeOut"				required="no"	type="numeric"			hint="cf request timeout in seconds" />		<cfset var local = structNew() />		<cfif structKeyExists(arguments, "requestTimeOut") AND arguments.requestTimeout >			<cfSetting requestTimeOut="#arguments.requestTimeout#" />		</cfif>		<cfScript>			if((!structKeyExists(arguments, "functionCode") OR !len(arguments.functionCode)) AND (!structKeyExists(arguments, "SubFunctionEvaluateCode") OR !len(arguments.SubFunctionEvaluateCode)))			{				local.returnStruct = structNew();				local.returnStruct['nodeKeyList']=structNew();				local.returnStruct['outputString']='<h3>Nothing Defined to Test and Output</h3>';				return serializeJson(local.returnStruct);			}			local.executionTime	= getTickCount();			/* get last result */				arguments.dumpObject = invokationToResultArray(argumentCollection=arguments);				if(arrayLen(arguments.dumpObject))					arguments.dumpObject = arguments.dumpObject[arrayLen(arguments.dumpObject)];				else					structDelete(arguments, "dumpObject");			/* end */			arguments.executionTime = getTickCount() - local.executionTime;			local.output = getDumpResultStatsDisplay(argumentCollection=arguments);			local.returnStruct = {};			local.returnStruct['outputString'] = local.output & getDumpLayout(argumentCollection=arguments);			if(structKeyExists(arguments,'dumpObject'))				local.returnStruct['nodeKeyList'] = getDumpScope(arguments.dumpObject);			else				local.returnStruct['nodeKeyList'] = arrayNew(1);			local.jsonReturn = serializeJson(local.returnStruct);			return local.jsonReturn;		</cfScript>	</cfFunction>	<cfFunction		Name			= "getArgumentParameterForm"		returnType		= "string"		Access			= "public"		Output			= "no"		Hint			= ""	>		<cfArgument name="functionCode"				required="no"	type="string"		hint="" />		<cfArgument name="SubFunctionEvaluateCode"	required="no"	type="string"		hint="" />		<cfArgument name="targetMethod"				required="yes"	type="variableName" hint="" />		<cfArgument name="onSubmit"					required="yes"	type="variableName"	hint="" />		<cfScript>			var local = structNew();			if			(				(structKeyExists(arguments, "functionCode") AND len(arguments.functionCode))			OR	(structKeyExists(arguments, "SubFunctionEvaluateCode") AND len(arguments.SubFunctionEvaluateCode))			)			{				local.obj = invokationToResultArray(argumentCollection=arguments);				local.obj = local.obj[1];				if(structKeyExists(local.obj, arguments.targetMethod))					local.obj = local.obj[arguments.targetMethod];			}else			{				local.struct = getIncludeVariableStruct();				if(structKeyExists(local.struct, arguments.targetMethod))					local.obj = local.struct[arguments.targetMethod];			}			local.metaData = getMetaData(local.obj);			local.parameters = local.metaData.parameters;		</cfScript>		<cfSaveContent Variable="local.return_string">			<cfInclude template="Layouts/ArgumentForm.cfm" />		</cfSaveContent>		<cfReturn local.return_string />	</cfFunction>	<cfFunction		name			= "sampleDump"		returnFormat	= "plain"		access			= "public"		output			= "no"		description		= ""		hint			= ""	>		<cfArgument name="sampleDumpTypeName"			required="yes"	type="variableName" hint="" />		<cfScript>			var local = structNew();			arguments.expand = 1;			arguments.asMetaData = 0;			arguments.isReturnUnformattedQuerySql = 1;			arguments.returnStringFormatMode = 'plain';			arguments.dumpFormat = 'html';			local.title = arguments.sampleDumpTypeName;			local.executedCode = "";			local.evaluateCode = "";		</cfScript>		<cfSwitch expression="#arguments.sampleDumpTypeName#">			<!--- to evaluate code --->				<cfCase value="directoryList">					<cfset local.title = 'directoryList' />					<cfset local.evaluateCode = "directoryList(getDirectoryFromPath(getCurrentTemplatePath()), false, 'query', '*', 'name asc')" />				</cfCase>				<cfCase value="componentGetMetaData">					<cfset local.title='getMetaData(this)' />					<cfset local.evaluateCode = "getMetaData(this)" />				</cfCase>				<cfCase value="getTempDirectory">					<cfset local.title = 'getTempDirectory()' />					<cfset local.evaluateCode = "getTempDirectory()" />				</cfCase>				<cfCase value="GetFileInfo">					<cfset local.title = 'getFileInfo()' />					<cfset local.evaluateCode = "getFileInfo(getCurrentTemplatePath())" />				</cfCase>			<!--- end --->			<cfCase value="OrmSessionDump">				<cfset local.title='Orm Session Dump' />				<cf_OrmSessionDump returnVariable="arguments.dumpObject" />				<cfset executedCode = getDirectoryFromPath(getCurrentTemplatePath()) & 'OrmSessionDump.cfm' />			</cfCase>			<cfCase value="GetHttpRequestData">				<cfset local.title = 'getHttpRequestData()' />				<cfset arguments.dumpObject = getHttpRequestData() />				<cfset local.executedCode = '<cfDump var="##getHttpRequestData()##" />' />			</cfCase>			<cfCase value="cfObjectCache">				<cfset local.title = 'cfObject action="clear"' />				<cfObjectCache action="clear" />				<cfset local.executedCode = '<cfObjectCache action="clear" />' />			</cfCase>			<cfCase value="directoryRead">				<cfset local.title = 'cfDirectory action="list"' />				<cfDirectory directory="#getDirectoryFromPath(getCurrentTemplatePath())#" name="arguments.dumpObject" action="list" recurse="no" type="all" sort="asc" />				<cfset local.executedCode = '<cfDirectory directory="#getDirectoryFromPath(getCurrentTemplatePath())#" name="arguments.dumpObject" action="list" recurse="no" type="all" sort="asc" />' />			</cfCase>			<cfCase value="FileOpen">				<cfset local.title = 'FileOpen()' />				<cfset arguments.dumpObject = FileOpen(getCurrentTemplatePath()) />				<cfset FileClose( arguments.dumpObject ) />				<cfset local.executedCode = '<cfset arguments.dumpObject = FileOpen(getCurrentTemplatePath()) />#chr(10)#<cfset FileClose( arguments.dumpObject ) />' />			</cfCase>			<!---			<cfCase value="EntityReload">				<cfset EntityReload() />				<cfset local.executedCode = 'EntityReload()' />				<cfset arguments.dumpObject = 'Entity Cache Reloaded' />			</cfCase>			--->			<cfCase value="ORMFlush">				<cfset ORMFlush() />				<cfset local.executedCode = 'ORMFlush()' />				<cfset arguments.dumpObject = 'Orm Data Cache Flushed' />			</cfCase>			<cfCase value="ORMReload">				<cfset ormReload() />				<cfset local.executedCode = 'ORMReload()' />				<cfset arguments.dumpObject = 'Orm Config Cache Reloaded' />			</cfCase>			<cfDefaultCase>				<cfThrow message="invalid sample type dump" detail="" />			</cfDefaultCase>		</cfSwitch>		<cfif len(local.evaluateCode) >			<cfset arguments.dumpObject = evaluate(local.evaluateCode) />			<cfset local.executedCode = local.evaluateCode />		</cfif>		<cfset local.toReturn = '<h4>#local.title# Sample Dump</h4>' & getDumpLayout(argumentCollection=arguments) />		<cfif len(local.executedCode) >			<cfset local.toReturn &= '<hr /><div style="font-size:0.8em"><b>Code Executed</b>:&nbsp;' & htmlCodeFormat(local.executedCode) & '</div>' />		</cfif>		<cfReturn local.toReturn />	</cfFunction>	<cfFunction		name		= "getFunctionMetaDataArray"		returnType	= "array"		access		= "private"		output		= "no"		description	= ""		hint		= ""	>		<cfArgument name="metaData"				required="yes"	type="struct"					hint="" />		<cfArgument name="isIncludeExtensions"	required="no"	type="boolean"	default="yes"	hint="" />		<cfScript>			var local = structNew();			local.returnArray = arrayNew(1);			if( structKeyExists(arguments.metaData , "functions" ) )			{				for(local.x=1; local.x LTE arrayLen(arguments.metaData.functions); ++local.x)				{					local.loop_array = arguments.metaData.functions[local.x];					if(!structKeyExists(local.loop_array, "access") OR local.loop_array.access EQ 'public' OR local.loop_array.access EQ 'remote')					{						local.loop_array.extendedByName = arguments.metaData.name;						arrayAppend(local.returnArray , local.loop_array);					}				}			}			if			(				arguments.isIncludeExtensions			AND				structKeyExists(arguments.metaData , "extends")			)			{				local.array = getFunctionMetaDataArray(arguments.metaData.extends);				if(arrayLen(local.array))					local.returnArray.addAll( local.array );				return local.returnArray;			}			return local.returnArray;		</cfScript>	</cfFunction>	<cfFunction		Name		= "getDumpScope"		returnType	= "array"		Access		= "private"		Output		= "no"		Hint		= ""	>		<cfArgument name="obj" required="yes" type="any" hint="" />		<cfScript>			var local = structNew();			local.return_array = arrayNew(1);			if( isStruct(arguments.obj) )			{				local.list = structKeyList(arguments.obj);				/* see if we can exchange component uppercase names for the names specified in .cfc file */					if					(						isValid("component" , arguments.obj)					OR						isInstanceOf(arguments.obj, 'WEB-INF.cfTags.component')					)					{						local.ExposeComponent	= Expose(arguments.obj);						local.functionArray		= getFunctionMetaDataArray(getMetaData(arguments.obj));						local.primaryFunctionList	= Expose(arguments.obj).getNonExtendedMethodNameList();						/* make the actual exchange in names ... all upper case for case sensative so easier to read */							local.methodList = CFMethods().Conversions().arrayStructKeyValuesToArray(local.functionArray,"name");							for(local.methodLoop=1; local.methodLoop LTE arrayLen(local.methodList); ++local.methodLoop)							{								local.methodName	= local.methodList[local.methodLoop];								local.isFound		= listFindNoCase(local.list , local.methodName);								if(local.isFound)									local.list = listAppend(listDeleteAt(local.list , local.isFound) , local.methodName);								else									local.list = listAppend(local.list, local.methodName);							}						/* end */					}				/* end */				local.list = listSort(local.list , "textnocase" , "asc" , chr(44));				for(local.x=1; local.x LTE listLen(local.list); ++local.x)				{					local.currentVariableName = listGetAt(local.list , local.x);					local.struct_loop = structNew();					local.struct_loop['name'] = local.currentVariableName;					local.struct_loop['type'] = "NULL";					/* type */						local.loop_child = arguments.obj[local.currentVariableName];						local.struct_loop.type = CFMethods().getVariableTypeName(local.loop_child);						if(local.struct_loop.type eq 'function')						{							local.metaData = getMetaData(local.loop_child);							local.struct_loop['returntype'] = 'any';							if(structKeyExists(local.metaData , "returnType"))								local.struct_loop['returntype'] = local.metaData.returnType;							if(structKeyExists(local, "ExposeComponent"))							{								local.struct_loop['isreturncomponent'] = local.ExposeComponent.isMethodReturnComponent(local.currentVariableName);								for(local.methodArrayLoop=arrayLen(local.functionArray); local.methodArrayLoop GT 0; local.methodArrayLoop=local.methodArrayLoop-1)								{									if(local.functionArray[local.methodArrayLoop].name EQ local.currentVariableName)									{										local.struct_loop["extendedbyname"] = local.functionArray[local.methodArrayLoop].extendedByName;										break;									}								}								if(not structKeyExists(local.struct_loop , "extendedbyname"))									local.struct_loop["extendedbyname"] = '(!!!variable implant...this method was set in here and does not actually live in this component!!!)';								local.struct_loop["isextendedmethod"]	= NOT listFindNoCase(local.primaryFunctionList , local.metaData.name);							}							if(structKeyExists(local.metaData , "access" ))								local.struct_loop['access'] = local.metaData.access;							if(structKeyExists(local.metaData , "hint" ))								local.struct_loop['hint'] = local.metaData.hint;							local.struct_loop['parameters'] = variables.lowerCaseArrayNodes(local.metaData.parameters);						}					/* end */					if( listFindNoCase( "function,struct,xml,array,component" , local.struct_loop.type ) )						arrayAppend( local.return_array , local.struct_loop );				}			}			Return local.return_array;		</cfScript>	</cfFunction>	<cfFunction		Name		= "lowerCaseArrayNodes"		returnType	= "array"		Access		= "private"		Output		= "no"		Hint		= ""	>		<cfArgument name="array" required="yes" type="array" hint="" />		<cfScript>			var local = structNew();			local.array = arrayNew(1);			for(local.x=1; local.x LTE arrayLen(arguments.array); ++local.x)			{				local.loop = arguments.array[local.x];				if( isStruct(local.loop) )					local.temp = variables.lowerCaseStruct(local.loop);				else					local.temp = local.loop;				arrayAppend( local.array , local.temp );			}			Return local.array;		</cfScript>	</cfFunction>	<cfFunction		Name		= "lowerCaseStruct"		returnType	= "struct"		Access		= "private"		Output		= "no"		Hint		= ""	>		<cfArgument name="struct" required="yes" type="struct" hint="" />		<cfset var local = structNew() />		<cfLoop collection="#arguments.struct#" item="local.loop" >			<cfset local[lcase(local.loop)] = arguments.struct[local.loop] />		</cfLoop>		<cfReturn local />	</cfFunction>	<cfFunction		name		= "getDumpLayout"		returnType	= "string"		access		= "public"		output		= "no"		description	= ""		hint		= ""	>		<cfArgument name="dumpObject"					required="no"	type="any"				hint="" />		<cfArgument name="expand"						required="no"	type="boolean"		default="yes" hint="" />		<cfArgument name="asMetaData"					required="no"	type="boolean"		default="no" hint="" />		<cfArgument name="returnStringFormatMode"		required="no"	type="variableName"	default="textarea" hint="" />		<cfArgument name="isReturnUnformattedQuerySql"	required="no"	type="boolean"		default="yes" hint="" />		<cfArgument name="dumpFormat"					required="no"	type="variableName"	default="html" hint="" />		<cfArgument name="dumpTop"						required="no"	type="string"			hint="" />		<cfArgument name="showUDFs"						required="no"	type="boolean"		default="no" hint="" />		<cfset var local = structNew() />		<!--- clear anything that might have been generated by even chHtmlHead --->			<!--- capture pre output such as cfHTMLHead tag output --->				<cfset local.headerBufferString = CFMethods().CF().getHeaderBufferString() />				<cfif len( trim(local.headerBufferString) ) >					<cfSaveContent Variable="local.output">						<div style="border:1px solid black;">							<div style="background:black;padding:5px;font-size:1em;color:white">								<i>cfHtmlHead Output</i>							</div>							<cfOutput>								<div style="background:white;padding:10;"><pre>#trim(local.headerBufferString)#</pre></div>							</cfOutput>						</div><br /><br />					</cfSaveContent>					clearHeaderBuffer					<cfset CFMethods().CF().clearHeaderBuffer() />				</cfif>			<!--- end --->		<!--- end --->		<cfScript>			local.output = '';			if( structKeyExists(arguments , "dumpObject") )			{				if( isSimpleValue(arguments.dumpObject) )				{					local.nodeDumpContent = arguments.dumpObject;					if( len(arguments.dumpObject) )					{						switch(arguments.returnStringFormatMode)						{							case	"plain":									local.nodeDumpContent = arguments.dumpObject;									break;							case	"html":									local.nodeDumpContent = '#htmlCodeFormat(arguments.dumpObject)#';									break;							default:									local.nodeDumpContent = '<textarea style="width:98%;min-width:400px;height:515px;font-size:11px" wrap="off">#htmlEditFormat(arguments.dumpObject)#</textarea>';									break;						}					}				}else				{					if( arguments.asMetaData )						arguments.dumpObject = getMetaData(arguments.dumpObject);					if(isStruct(arguments.dumpObject) AND getMetaData(arguments.dumpObject).name NEQ 'coldfusion.runtime.com.ComProxy')						CFMethods().structDeleteNulls(arguments.dumpObject);					local.argStruct = structNew();					local.argStruct.var=arguments.dumpObject;					local.argStruct.expand=arguments.expand;					local.argStruct.format=arguments.dumpFormat;					local.argStruct.showUDFs=arguments.showUDFs;					if(structKeyExists(arguments, "dumpTop") AND isNumeric(arguments.dumpTop))						local.argStruct.top = arguments.dumpTop;					local.nodeDumpContent = CFMethods().dump(argumentCollection=local.argStruct);					if( isQuery(arguments.dumpObject))					{						local.argStruct=structNew();						local.argStruct.var=getMetaData(arguments.dumpObject);						local.argStruct.label="Column MetaData";						local.argStruct.expand="no";						local.argStruct.format=arguments.dumpFormat;						local.argStruct.showUdfs=arguments.showUdfs;						if(structKeyExists(arguments, "dumpTop") AND isNumeric(arguments.dumpTop))							local.argStruct.top = arguments.dumpTop;						local.nodeDumpContent &= '<br /><h4>getMetaData:</h4>' & CFMethods().dump(argumentCollection=local.argStruct);					}					if					(						arguments.isReturnUnformattedQuerySql					AND						isQuery(arguments.dumpObject)					)					{						local.queryMetaData = arguments.dumpObject.getMetaData().getExtendedMetaData();						if( structKeyExists( local , "queryMetaData" ) )							local.nodeDumpContent &=							'								<hr />								<h4>Raw unformatted SQL string</h4>								<div style="font-size:10px">#htmlCodeFormat(arguments.dumpObject.getMetaData().getExtendedMetaData().sql)#</div>							';					}				}				local.output &= '<div style="display:table;padding:3px;border:1px dotted black;">' & local.nodeDumpContent & '</div>';			}		</cfScript>		<!--- visual interpretations of return --->			<cfif structKeyExists(arguments, "dumpObject" ) AND isSimpleValue(arguments.dumpObject) AND NOT len(arguments.dumpObject) >				<cfset local.output &= '<i>[EMPTY-STRING]</i>' />			</cfif>			<cfif not structKeyExists(arguments , "dumpObject") >				<cfset local.output &= '<i>[VOID-NULL-UNDEFINED]</i>' />			</cfif>		<!--- end --->		<cfReturn local.output />	</cfFunction>	<cfFunction		name		= "functionEvaluateNotation"		returnType	= "any"		access		= "public"		output		= "no"		description	= ""		hint		= ""	>		<cfArgument name="notation" required="yes" type="string" hint="" />		<cfScript>			var local = structNew();			local.fileName	= 'TestCase.cfm';			local.filePath	= getDirectoryFromPath(getCurrentTemplatePath()) & local.fileName;			local.output=			'				<cfFunction					name		= "executionTest"					returnType	= "any"					access		= "public"					output		= "yes"				>					'&arguments.notation&'				</cfFunction>			';			fileWrite(local.filePath, local.output);		</cfScript>		<cfInclude template="#local.fileName#" />		<cfSaveContent Variable="local.outputCapture">			<cfset local.result = executionTest() />		</cfSaveContent>		<cfset structDelete(variables, "executionTest") />		<cfif structKeyExists(local, "result") >			<cfReturn local.result />		</cfif>		<cfif len(trim(local.outputCapture)) >			<cfReturn local.outputCapture />		</cfif>		<cfReturn '<i style="color:red">Result was void or did not include a return variable</i>' />	</cfFunction>	<cfFunction		name		= "getDumpResultStatsDisplay"		returnType	= "string"		access		= "public"		output		= "no"		description	= ""		hint		= ""	>		<cfArgument name="dumpObject"		required="no"	type="any"							hint="" />		<cfArgument name="executionTime"	required="no"	type="string"		default="?"		hint="" />		<cfScript>			var local = structNew();			local.output =  '<b>Execution Time</b>: #arguments.executionTime#';			if(structKeyExists(arguments,'dumpObject') AND isSimpleValue(arguments.dumpObject))			{				local.output &=	';&nbsp;<b>Character Count</b>: ' & len(arguments.dumpObject);				local.output &=	';&nbsp;<b>Line Count</b>: ' & listLen(arguments.dumpObject,chr(10)&chr(13));			}			return local.output;		</cfScript>	</cfFunction></cfComponent>